---

title: "Inventory System 이해하기"
author: Manyeo
categories: 
- Unity
tags: 
- Code Analysis

date: 2021-12-29

---

Code by Rito15


<br>


# 시작

> RPG Inventory System을 한줄 한줄 분석한다.

<br>

# 구성

> 분석 후에 정리하도록 한다.

<br>


# 코드 분석

## 📜Item.cs

<br>

```cs
public abstract class Item
{
    public ItemData Data { get; private set; }

    public Item(ItemData data) => Data = data;
}
```

`Item` Class의 본문이다.

<br>

```cs
 public abstract class Item
```

`Item` 클래스를 추상 클래스 (`abstract class`)로 선언한다.

추상 클래스로 선언하는 이유는 상속받을 자식 클래스(**`Child Class`**)에서 추상 메서드(**`abstract method`**)를 구현하는 것이 목적일 때 쓰이는데 여기선 왜 쓰건지 모르겠다. ~~부모 클래스로서 쓰일 것이기 때문에 구현은 자식 클래스에 맡기려고 한 것일 수도 있겠다. `abstract`를 **사용의 목적**보다 **표시의 목적**으로 쓴 것으로 생각하자.~~

또한, `Monobehaviour`를 상속하지 않았으므로 컴포넌트로서 기능하지 않겠다는 의미이다. 

<u>+*추가* : 추상 클래스로 사용한 이유는 직접 인스턴스 생성되는 것을 막기 위함이다. 자식 클래스에서도 `Monobehaviour`를 상속하지 않기 때문.</u>

<br>

```cs
public ItemData Data { get; private set; }
```

`ItemData` 형식의 프로퍼티 Data를 선언한다. 

프로퍼티기 때문에 접근 한정자는  `public`으로 설정한다. 프로퍼티로 설정한 것은 `getter`와 `setter` 함수 대신에 외부에서 접근하겠다는 의미이다. setter는 `private`으로 설정해서 외부에서 값을 넣을 수는 없게 하겠다는 의미이다. 아래는 해당 프로퍼티를 함수로 치환한 것이다.




```cs
public ItemData GetData();
private ItemData SetData(value);
```

`ItemData`는 다른 스크립트의 사용자 정의 클래스이므로 좀 있다가 서술하겠다.

<br>


```cs
public Item(ItemData data) => Data = data;
```

`Item` 클래스의 생성자(**`Constructor`**)를 선언한다.

생성자 매개변수로 `ItemData` 형식의 data변수를 받고 Data 프로퍼티 값을 data 매개변수 값으로 초기화 한다. 딱 봤을 때는 람다 식(`Lambda Expression`)으로 보이지만 사실 람다는 아니고, 람다의 형태를 멤버에서 쓰는 **식 본문 멤버**(`Expression-bodied members`)문법이다. C# 6과 C# 7.0 이상부터 사용 가능하다. 원래 문장으로 바꾸면 아래와 같다.

```cs
// public Item(ItemData data) => Data = data;와 완전히 같은 문장이다.
// 프로그래머의 귀차니즘은 끝이 없다.
public Item(ItemData data) 
{
    Data = data;
}
```

**식 본문 멤버**는 생성자만이 아니라 프로퍼티, 종료자, 인덱서, 메서드 전부 사용 가능하다.

<br>

## 📜EquipmentItem.cs

<br>

`Item` 클래스는 두 개의 자식 클래스를 가지고 있다. 그 중 하나인 `EquipmentItem`을 먼저 살펴보자.

```cs
public abstract class EquipmentItem : Item
{
    public EquipmentItemData EquipmentData { get; private set; }

    public int Durability
    {
        get => _durability;
        set
        {
            if (value < 0) value = 0;
            if (value > EquipmentData.MaxDurability)
                value = EquipmentData.MaxDurability;

            _durability = value;
        }
    }
    private int _durability;

    public EquipmentItem(EquipmentItemData data) : base(data)
    {
        EquipmentData = data;
        Durability = data.MaxDurability;
    }
}
```

`EquipmentItem` 클래스의 본문이다.

<br>

```cs
public abstract class EquipmentItem : Item
```

`EquipmentItem` 클래스를 추상 클래스로 선언한다. `Item` 클래스를 상속받는다.

`Item` 클래스를 상속받으면서 `Item` 클래스의 필드를 사용할 수 있게 되었다. 필드로 사용된 Data와 생성자가 클래스 위에 추가 되었다고 생각하면 된다.

<br>

```cs
public EquipmentItemData EquipmentData { get; private set; }
```
`EquipmentItemData`형식의 프로퍼티 EquipmentData를 선언한다.

<br>

```cs
public int Durability
{
    get => _durability;
    set
    {
        if (value < 0) value = 0;
        if (value > EquipmentData.MaxDurability)
            value = EquipmentData.MaxDurability;

        _durability = value;
    }
}
```
`int` 형식의 프로퍼티 Durability를 선언한다.

Durability는 '내구성'을 뜻하므로 장비의 내구도에 관련된 프로퍼티일 것이다. 우선 `getter`로 멤버변수 _durability를 가져온다. _durability는 이 식의 다음에 선언되므로 해매지 말자. 

`setter`에서 `value`가 0보다 작으면 `value`에 0을 대입하고 `value`가 `EquipmentData.MaxDurability`보다 크면 `value`에 EquipmentData.MaxDurability를 대입한다. 마지막으로 _durability 멤버 변수에 value를 대입한다.

최소값과 최대값을 벗어나지 않게 하는 코드다. EquipmentData.MaxDurability는 최대 내구도를 가져오는 프로퍼티다.

<br>

```cs
private int _durability;
```

`int` 형식의 멤버변수 _durability를 선언한다.

내구도 값을 저장할 변수로 쓰일 목적으로 선언된 것으로 보인다. Durability 프로퍼티가 이 멤버변수의 값을 가져오거나 저장할 때 애용할 것이다. 변수명 앞에 _ (`Underscore`)가 붙은 것은 `멤버`변수라서 그렇다. 일반 변수는 붙이지 않는다. 일종의 코드 규칙 (`Code Convention`)이다. 내가 하는 코드방식과 유사해서 좀 놀랬다.

<br>

```cs
public EquipmentItem(EquipmentItemData data) : base(data)
{
    EquipmentData = data;
    Durability = data.MaxDurability;
}
```

`EquipmentItem` 클래스의 생성자(**`Constructor`**)를 선언한다.

우선 `base(data)`를 상속하고 있으므로 부모의 생성자를 먼저 호출한 뒤 자신의 생성자를 호출한다. 따라서 `Item` 클래스의 Data 프로퍼티에 data로 초기화가 진행된다.

그런 다음 EquipmentData 프로퍼티에 매개변수 data로 초기화하고 Durability 프로퍼티에 data.MaxDurability로 초기화한다. 데이터를 모두 초기화 함과 동시에 내구도는 최대 내구도로 설정이 된다.

<br>

## 📜CountableItem.cs

<br>

```cs
public abstract class CountableItem : Item
{
    public CountableItemData CountableData { get; private set; }

    public int Amount { get; protected set; }

    public int MaxAmount => CountableData.MaxAmount;

    public bool IsMax => Amount >= CountableData.MaxAmount;

    public bool IsEmpty => Amount <= 0;


    public CountableItem(CountableItemData data, int amount = 1) : base(data)
    {
        CountableData = data;
        SetAmount(amount);
    }


    public void SetAmount(int amount)
    {
        Amount = Mathf.Clamp(amount, 0, MaxAmount);
    }


    public int AddAmountAndGetExcess(int amount)
    {
        int nextAmount = Amount + amount;
        SetAmount(nextAmount);

        return (nextAmount > MaxAmount) ? (nextAmount - MaxAmount) : 0;
    }


    public CountableItem SeperateAndClone(int amount)
    {
        if (Amount <= 1) return null;

        if (amount > Amount - 1)
            amount = Amount - 1;

        Amount -= amount;
        return Clone(amount);
    }

    protected abstract CountableItem Clone(int amount);
}
```

`CountableItem` 클래스의 본문이다.

<br>

```cs
public abstract class CountableItem : Item
```

`CountableItem` 클래스를 추상 클래스로 선언한다. `Item` 클래스를 상속받는다.
`EquipmentItem` 클래스와 같은 구조로 작성 되어있음을 알 수 있다.

<br>

```cs
public CountableItemData CountableData { get; private set; }
```

`CountableItemData` 형식의 프로퍼티 CountableData를 선언한다.